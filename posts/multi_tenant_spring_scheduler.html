<html>
  <head>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <link rel="stylesheet" type="text/css" href="/vendors/css/normalize.css">
    <link rel="stylesheet" type="text/css" href="/vendors/css/Grid.css">
    <link rel="stylesheet" type="text/css" href="/vendors/css/ionicons.min.css">
    <link rel="stylesheet" type="text/css" href="/vendors/css/animate.css">
    <link rel="stylesheet" type="text/css" href="/resources/css/style.css">
    <link rel="stylesheet" type="text/css" href="/resources/css/queries.css">
    <link href="https://fonts.googleapis.com/css?family=Lato:100,300,300i,400&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.6.0/styles/stackoverflow-dark.min.css">

    <script src="https:////cdnjs.cloudflare.com/ajax/libs/highlight.js/10.6.0/highlight.min.js"></script>
    <script>
      hljs.highlightAll();
    </script>

    <title>Coding Moments</title>
  </head>

  <body>
    <header>
      <nav>
        <div class="row">
          <a class="mobile-nav-icon js--nav-icon"><i class="ion-navicon-round"></i></a>
          <ul class="main-nav js--main-nav">
            <li><a href="/">Latest Posts</a></li>
            <li><a href="/about.html">About Me</a></li>
          </ul>
        </div>
      </nav>
    </header>

    <section class="section-post-content" id="post-content">
      <div class="row">
        <h2>Multi-tenant Spring Scheduler</h2>
      </div>
      <div class="row">
        <h3>Introduction</h3>
        <div>
          <p>At <a href="https://www.maxxton.com/">Maxxton</a>, recently one of the projects was having a requirement of scheduling a task with fixed delay and with multi-tenant support. That means, if there were N tenants, we needed to schedule that task for N tenants.
          </p>
          <p>Using Spring Scheduler was the obvious choice. But using <a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/scheduling/annotation/Scheduled.html">@Scheduled</a> annotation was not an option, as we wanted to schedule the task per tenant - programmatically.
          </p>
        </div>
        <h3>Programmatic Spring Scheduling</h3>
        <p>Spring provides an interface <a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/scheduling/TaskScheduler.html">TaskScheduler</a> which is an abstraction for the asynchronous scheduling of tasks. It has variety of methods for scheduling tasks to run at some point in future.</p>
        <p>For our case, we used the method <code>scheduleWithFixedDelay(Runnable task, long delay)</code>.</p>
        <p>Below is the simplified version of the approach that we had used to accomplish multi-tenant support.</p>
        <pre><code class="language-java">@Service
public class MultiTenantSchedulerService {

  private static final Logger LOGGER = LoggerFactory.getLogger(MultiTenantSchedulerService.class);

  private final static int[] TENANT_IDS = { 1, 2, 3, 4, 5 };
  private final static int FIXED_DELAY_SECONDS = 15;

  @Autowired
  private TaskScheduler taskScheduler;

  @PostConstruct
  public void scheduleTasksForAllTenants() {
    for (int tenantId : TENANT_IDS) {
      // Schedule task for each tenant
      taskScheduler.scheduleWithFixedDelay(() -> {
        processTenant(tenantId);
      }, FIXED_DELAY_SECONDS * 1000);
    }
  }

  private void processTenant(int tenantId) {
    LOGGER.info("processTenant for tenant - {}", tenantId);
    // Set tenant in the context
    try {
      // Thread sleep represents the time taken by the business logic
      Thread.sleep(3000);
    }
    catch (InterruptedException e) {
    }
  }</code></pre>
        <p>By default, Spring scheduler uses single thread for executing the scheduled tasks. So, in above example, it will run the process for one tenant at a time.</p>
        <p>To run the process for all tenants in parallel, you will have to configure thread pool with sufficient number of threads.</p>
        <p>For that Spring provides TaskScheduler implementations which expose the configuration parameters as Java Beans.</p>
        <p>Below is an example of such configuration.</p>
        <pre><code class="language-java">  @Bean
  public TaskScheduler taskScheduler() {
    ThreadPoolTaskScheduler taskScheduler = new ThreadPoolTaskScheduler();
    taskScheduler.setPoolSize(10);
    taskScheduler.setThreadNamePrefix("taskScheduler");
    taskScheduler.initialize();
    return taskScheduler;
  }</code></pre>
        <p>This approach worked fine with us.</p>
        <h3>Scheduler Stops Running</h3>
        <p>I was monitoring the schedulder for one tenant. After seeing it executed number of times, I saw that it suddently stopped! It puzzled me - WHY?</p>
        <p>Logs were clean, there were no exceptions. It was taking my time and was becoming hard to understand what was happening.</p>
        <p>After few rounds of more testing, I observed that a call to our Oracle database procedure was taking long time. I kept watch on that Oracle session until that session became inactive. I was expecting that now the scheduled task should proceed ahead. But it didn't!</p>
        <p>Finally, we decided to take thread dump to see what was going with those threads. And we saw something like below:</p>
        <img src="/resources/images/thread-hang.png" />
        <br/><br/>
        <p>This is a problem of hanging threads. There are several reasons a thread hangs. If you want to know more about this, you can read the <a href="https://www.codementor.io/@suryab/threads-stuck-in-java-net-socketinputstream-socketread0-rh26o1p1z">article</a>.</p>
        <h3>What We Did?</h3>
        <p>It became clear to us that anything can go wrong. In all cases, we needed to ensure that scheduler was always running. What could be better than monitoring! In our case, it was easy for us to predict if the scheduler is stuck based on values of records in database tables. At the end, scheduler was processing the records in the database. We created a metric for Prometheus and added a visualization on Grafana dashboard. Creating alert mechanism was the next step. With this, we could make sure that scheduler was always running.</p>
        <h3>Key Takeaways</h3>
        <p>By default, Spring scheduler uses single thread for executing the scheduled tasks. You have to configure thread pool if you want to use multiple threads.</p>
        <p>A thread can hang for several reasons. This stops the scheduler.</p>
        <p>Having a monitoring and alerting on the scheduler helps you to ensure that it is always running.</p>
      </div>
    </section>

    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.4.1/jquery.min.js"></script>
    <script src="/vendors/js/jquery.waypoints.min.js"></script>
    <script src="/resources/js/scripts.js"></script>
  </body>
</html>